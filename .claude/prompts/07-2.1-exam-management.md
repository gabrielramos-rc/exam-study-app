# Task 2.1: Exam Management

## Context

This task begins **Phase 2: Admin & Import** of the Exam Study App. Phase 1 established the project foundation including Next.js setup, Tailwind/shadcn styling, Prisma database with PostgreSQL, and the basic layout with sidebar navigation. The exam list page (`/admin/exams`) and new exam page (`/admin/exams/new`) currently exist as placeholders with disabled forms.

This task implements full CRUD functionality for exams, allowing the user to create, view, and delete exams. Exams are the top-level container for questions - each exam represents a certification (e.g., "GCP Professional Cloud Security Engineer") and will later contain imported questions.

## Objective

Implement complete exam management functionality: create exams, list exams with stats, view exam details, and delete exams with confirmation.

## Git Workflow

Before starting, set up your branch:

```bash
# Ensure you're on dev and up to date
git checkout dev
git pull origin dev

# Create task-specific branch
git checkout -b feature/2.1-exam-management
```

## Instructions

### Step 1: Create the Textarea Component

The exam form needs a textarea for the description field. Add the shadcn/ui textarea component:

```bash
npx shadcn@latest add textarea
```

This will create `src/components/ui/textarea.tsx`.

### Step 2: Create TypeScript Types for Exams

Create the types file for exam-related data structures. Create `src/types/exam.ts`:

```typescript
// src/types/exam.ts

// Response type for GET /api/exams (list)
export interface ExamListItem {
  id: string;
  name: string;
  description: string | null;
  questionCount: number;
  answeredCount: number;
  accuracy: number;
  dueForReview: number;
  createdAt: string;
  updatedAt: string;
}

export interface ExamListResponse {
  exams: ExamListItem[];
}

// Request type for POST /api/exams
export interface CreateExamRequest {
  name: string;
  description?: string;
}

// Response type for POST /api/exams
export interface CreateExamResponse {
  id: string;
  name: string;
  description: string | null;
  createdAt: string;
}

// Response type for GET /api/exams/[examId]
export interface ExamDetailResponse {
  id: string;
  name: string;
  description: string | null;
  stats: {
    totalQuestions: number;
    answered: number;
    correct: number;
    accuracy: number;
    dueForReview: number;
    bySection: Array<{
      sectionId: string;
      section: string;
      total: number;
      correct: number;
      accuracy: number;
    }>;
  };
  createdAt: string;
}

// Response type for DELETE /api/exams/[examId]
export interface DeleteExamResponse {
  success: boolean;
  deleted: {
    questions: number;
    answers: number;
    srsCards: number;
  };
}

// API Error response
export interface ApiError {
  error: {
    code: string;
    message: string;
    details?: Record<string, unknown>;
  };
}
```

Update the main types export file `src/types/index.ts`:

```typescript
// src/types/index.ts

export * from './exam';
```

### Step 3: Create the POST /api/exams Endpoint

Create the API route for creating exams. Create `src/app/api/exams/route.ts`:

```typescript
// src/app/api/exams/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

// GET /api/exams - List all exams with stats
export async function GET() {
  try {
    const exams = await prisma.exam.findMany({
      orderBy: { createdAt: 'desc' },
      include: {
        _count: {
          select: { questions: true },
        },
      },
    });

    // Get additional stats for each exam
    const examsWithStats = await Promise.all(
      exams.map(async (exam) => {
        // Count answered questions
        const answeredCount = await prisma.answer.count({
          where: {
            question: { examId: exam.id },
          },
        });

        // Calculate accuracy (only if there are answers)
        let accuracy = 0;
        if (answeredCount > 0) {
          const correctCount = await prisma.answer.count({
            where: {
              question: { examId: exam.id },
              correct: true,
            },
          });
          accuracy = Math.round((correctCount / answeredCount) * 100 * 10) / 10;
        }

        // Count due for review
        const dueForReview = await prisma.srsCard.count({
          where: {
            question: { examId: exam.id },
            nextReview: { lte: new Date() },
          },
        });

        return {
          id: exam.id,
          name: exam.name,
          description: exam.description,
          questionCount: exam._count.questions,
          answeredCount,
          accuracy,
          dueForReview,
          createdAt: exam.createdAt.toISOString(),
          updatedAt: exam.updatedAt.toISOString(),
        };
      })
    );

    return NextResponse.json({ exams: examsWithStats });
  } catch (error) {
    console.error('Error fetching exams:', error);
    return NextResponse.json(
      {
        error: {
          code: 'SERVER_ERROR',
          message: 'Failed to fetch exams',
        },
      },
      { status: 500 }
    );
  }
}

// POST /api/exams - Create a new exam
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();

    // Validate request body
    if (!body.name || typeof body.name !== 'string') {
      return NextResponse.json(
        {
          error: {
            code: 'VALIDATION_ERROR',
            message: 'Name is required and must be a string',
          },
        },
        { status: 400 }
      );
    }

    const name = body.name.trim();
    if (name.length === 0) {
      return NextResponse.json(
        {
          error: {
            code: 'VALIDATION_ERROR',
            message: 'Name cannot be empty',
          },
        },
        { status: 400 }
      );
    }

    if (name.length > 200) {
      return NextResponse.json(
        {
          error: {
            code: 'VALIDATION_ERROR',
            message: 'Name cannot exceed 200 characters',
          },
        },
        { status: 400 }
      );
    }

    const description = body.description?.trim() || null;
    if (description && description.length > 1000) {
      return NextResponse.json(
        {
          error: {
            code: 'VALIDATION_ERROR',
            message: 'Description cannot exceed 1000 characters',
          },
        },
        { status: 400 }
      );
    }

    // Check for duplicate name
    const existingExam = await prisma.exam.findFirst({
      where: { name: { equals: name, mode: 'insensitive' } },
    });

    if (existingExam) {
      return NextResponse.json(
        {
          error: {
            code: 'CONFLICT',
            message: 'An exam with this name already exists',
          },
        },
        { status: 409 }
      );
    }

    // Create the exam
    const exam = await prisma.exam.create({
      data: {
        name,
        description,
      },
    });

    return NextResponse.json(
      {
        id: exam.id,
        name: exam.name,
        description: exam.description,
        createdAt: exam.createdAt.toISOString(),
      },
      { status: 201 }
    );
  } catch (error) {
    console.error('Error creating exam:', error);
    return NextResponse.json(
      {
        error: {
          code: 'SERVER_ERROR',
          message: 'Failed to create exam',
        },
      },
      { status: 500 }
    );
  }
}
```

### Step 4: Create the GET/DELETE /api/exams/[examId] Endpoints

Create the API route for individual exam operations. Create `src/app/api/exams/[examId]/route.ts`:

```typescript
// src/app/api/exams/[examId]/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

interface RouteParams {
  params: Promise<{ examId: string }>;
}

// GET /api/exams/[examId] - Get exam with stats
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const { examId } = await params;

    const exam = await prisma.exam.findUnique({
      where: { id: examId },
      include: {
        _count: {
          select: { questions: true },
        },
      },
    });

    if (!exam) {
      return NextResponse.json(
        {
          error: {
            code: 'NOT_FOUND',
            message: 'Exam not found',
            details: { examId },
          },
        },
        { status: 404 }
      );
    }

    // Get answer stats
    const answers = await prisma.answer.findMany({
      where: { question: { examId } },
      select: { correct: true },
    });

    const answered = answers.length;
    const correct = answers.filter((a) => a.correct).length;
    const accuracy = answered > 0 ? Math.round((correct / answered) * 100 * 10) / 10 : 0;

    // Get due for review count
    const dueForReview = await prisma.srsCard.count({
      where: {
        question: { examId },
        nextReview: { lte: new Date() },
      },
    });

    // Get section breakdown using raw query for JSONB access
    const sectionStats = await prisma.$queryRaw<
      Array<{
        sectionId: string | null;
        section: string | null;
        total: bigint;
        correct: bigint;
      }>
    >`
      SELECT
        (q.data->>'sectionId') as "sectionId",
        (q.data->>'section') as section,
        COUNT(DISTINCT q.id)::bigint as total,
        COUNT(DISTINCT CASE WHEN a.correct = true THEN a.id END)::bigint as correct
      FROM "Question" q
      LEFT JOIN "Answer" a ON a."questionId" = q.id
      WHERE q."examId" = ${examId}
      GROUP BY (q.data->>'sectionId'), (q.data->>'section')
      ORDER BY (q.data->>'sectionId')
    `;

    const bySection = sectionStats.map((s) => ({
      sectionId: s.sectionId || 'Unknown',
      section: s.section || 'Unknown',
      total: Number(s.total),
      correct: Number(s.correct),
      accuracy: Number(s.total) > 0 ? Math.round((Number(s.correct) / Number(s.total)) * 100) : 0,
    }));

    return NextResponse.json({
      id: exam.id,
      name: exam.name,
      description: exam.description,
      stats: {
        totalQuestions: exam._count.questions,
        answered,
        correct,
        accuracy,
        dueForReview,
        bySection,
      },
      createdAt: exam.createdAt.toISOString(),
    });
  } catch (error) {
    console.error('Error fetching exam:', error);
    return NextResponse.json(
      {
        error: {
          code: 'SERVER_ERROR',
          message: 'Failed to fetch exam',
        },
      },
      { status: 500 }
    );
  }
}

// DELETE /api/exams/[examId] - Delete exam and all related data
export async function DELETE(request: NextRequest, { params }: RouteParams) {
  try {
    const { examId } = await params;

    // Check if exam exists
    const exam = await prisma.exam.findUnique({
      where: { id: examId },
      include: {
        _count: {
          select: {
            questions: true,
          },
        },
      },
    });

    if (!exam) {
      return NextResponse.json(
        {
          error: {
            code: 'NOT_FOUND',
            message: 'Exam not found',
            details: { examId },
          },
        },
        { status: 404 }
      );
    }

    // Get counts before deletion for response
    const questionIds = await prisma.question.findMany({
      where: { examId },
      select: { id: true },
    });
    const questionIdList = questionIds.map((q) => q.id);

    const answersCount = await prisma.answer.count({
      where: { questionId: { in: questionIdList } },
    });

    const srsCardsCount = await prisma.srsCard.count({
      where: { questionId: { in: questionIdList } },
    });

    // Delete exam (cascades to questions, answers, srsCards, bookmarks, studyProgress)
    await prisma.exam.delete({
      where: { id: examId },
    });

    return NextResponse.json({
      success: true,
      deleted: {
        questions: exam._count.questions,
        answers: answersCount,
        srsCards: srsCardsCount,
      },
    });
  } catch (error) {
    console.error('Error deleting exam:', error);
    return NextResponse.json(
      {
        error: {
          code: 'SERVER_ERROR',
          message: 'Failed to delete exam',
        },
      },
      { status: 500 }
    );
  }
}
```

### Step 5: Install React Hook Form and Zod for Form Handling

Install the required packages for form handling:

```bash
npm install react-hook-form zod @hookform/resolvers
```

### Step 6: Create the Exam Form Component

Create a reusable form component for creating exams. Create `src/components/exam/exam-form.tsx`:

```typescript
// src/components/exam/exam-form.tsx

'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Loader2 } from 'lucide-react';
import type { ApiError } from '@/types';

const examSchema = z.object({
  name: z
    .string()
    .min(1, 'Name is required')
    .max(200, 'Name cannot exceed 200 characters')
    .trim(),
  description: z
    .string()
    .max(1000, 'Description cannot exceed 1000 characters')
    .trim()
    .optional()
    .transform((val) => val || undefined),
});

type ExamFormData = z.infer<typeof examSchema>;

interface ExamFormProps {
  onCancel: () => void;
}

export function ExamForm({ onCancel }: ExamFormProps) {
  const router = useRouter();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [serverError, setServerError] = useState<string | null>(null);

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<ExamFormData>({
    resolver: zodResolver(examSchema),
    defaultValues: {
      name: '',
      description: '',
    },
  });

  const onSubmit = async (data: ExamFormData) => {
    setIsSubmitting(true);
    setServerError(null);

    try {
      const response = await fetch('/api/exams', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        const errorData: ApiError = await response.json();
        setServerError(errorData.error.message);
        return;
      }

      const result = await response.json();
      // Redirect to the exam detail page
      router.push(`/admin/exams/${result.id}`);
    } catch {
      setServerError('An unexpected error occurred. Please try again.');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Card className="max-w-2xl">
      <CardHeader>
        <CardTitle>Exam Details</CardTitle>
        <CardDescription>
          Enter the details for your new exam.
        </CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          {serverError && (
            <div className="rounded-md bg-destructive/10 border border-destructive/20 p-3">
              <p className="text-sm text-destructive">{serverError}</p>
            </div>
          )}

          <div className="space-y-2">
            <label htmlFor="name" className="text-sm font-medium">
              Exam Name <span className="text-destructive">*</span>
            </label>
            <Input
              id="name"
              placeholder="e.g., GCP Professional Cloud Security Engineer"
              {...register('name')}
              aria-invalid={!!errors.name}
            />
            {errors.name && (
              <p className="text-sm text-destructive">{errors.name.message}</p>
            )}
          </div>

          <div className="space-y-2">
            <label htmlFor="description" className="text-sm font-medium">
              Description
            </label>
            <Textarea
              id="description"
              placeholder="e.g., Practice questions for the GCP Security certification exam"
              rows={3}
              {...register('description')}
              aria-invalid={!!errors.description}
            />
            {errors.description && (
              <p className="text-sm text-destructive">{errors.description.message}</p>
            )}
          </div>

          <div className="flex gap-4">
            <Button type="submit" disabled={isSubmitting}>
              {isSubmitting && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Create Exam
            </Button>
            <Button type="button" variant="outline" onClick={onCancel} disabled={isSubmitting}>
              Cancel
            </Button>
          </div>
        </form>
      </CardContent>
    </Card>
  );
}
```

### Step 7: Create the Exam Card Component

Create a component for displaying exam cards in the list. Create `src/components/exam/exam-card.tsx`:

```typescript
// src/components/exam/exam-card.tsx

'use client';

import Link from 'next/link';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { BookOpen, CheckCircle, Clock, BarChart3 } from 'lucide-react';
import type { ExamListItem } from '@/types';

interface ExamCardProps {
  exam: ExamListItem;
}

export function ExamCard({ exam }: ExamCardProps) {
  const hasQuestions = exam.questionCount > 0;
  const hasAnswers = exam.answeredCount > 0;

  return (
    <Card className="hover:border-primary/50 transition-colors">
      <CardHeader className="pb-2">
        <div className="flex items-start justify-between">
          <div className="space-y-1">
            <CardTitle className="text-xl">
              <Link href={`/admin/exams/${exam.id}`} className="hover:underline">
                {exam.name}
              </Link>
            </CardTitle>
            {exam.description && (
              <CardDescription className="line-clamp-2">{exam.description}</CardDescription>
            )}
          </div>
          {exam.dueForReview > 0 && (
            <Badge variant="secondary" className="ml-2">
              {exam.dueForReview} due
            </Badge>
          )}
        </div>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="grid grid-cols-2 sm:grid-cols-4 gap-4 text-sm">
          <div className="flex items-center gap-2 text-muted-foreground">
            <BookOpen className="h-4 w-4" />
            <span>{exam.questionCount} questions</span>
          </div>
          <div className="flex items-center gap-2 text-muted-foreground">
            <CheckCircle className="h-4 w-4" />
            <span>{exam.answeredCount} answered</span>
          </div>
          <div className="flex items-center gap-2 text-muted-foreground">
            <BarChart3 className="h-4 w-4" />
            <span>{hasAnswers ? `${exam.accuracy}%` : '-'} accuracy</span>
          </div>
          <div className="flex items-center gap-2 text-muted-foreground">
            <Clock className="h-4 w-4" />
            <span>{exam.dueForReview} to review</span>
          </div>
        </div>

        <div className="flex gap-2">
          {hasQuestions ? (
            <>
              <Button asChild size="sm">
                <Link href={`/study/${exam.id}`}>Study</Link>
              </Button>
              <Button asChild variant="outline" size="sm">
                <Link href={`/admin/exams/${exam.id}`}>Manage</Link>
              </Button>
            </>
          ) : (
            <Button asChild size="sm">
              <Link href={`/admin/exams/${exam.id}`}>Import Questions</Link>
            </Button>
          )}
        </div>
      </CardContent>
    </Card>
  );
}
```

### Step 8: Create the Delete Exam Dialog Component

Create a confirmation dialog for deleting exams. First, add the AlertDialog component:

```bash
npx shadcn@latest add alert-dialog
```

Then create `src/components/exam/delete-exam-dialog.tsx`:

```typescript
// src/components/exam/delete-exam-dialog.tsx

'use client';

import { useState } from 'react';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from '@/components/ui/alert-dialog';
import { Button } from '@/components/ui/button';
import { Loader2, Trash2 } from 'lucide-react';

interface DeleteExamDialogProps {
  examId: string;
  examName: string;
  questionCount: number;
  onDeleted: () => void;
}

export function DeleteExamDialog({
  examId,
  examName,
  questionCount,
  onDeleted,
}: DeleteExamDialogProps) {
  const [isDeleting, setIsDeleting] = useState(false);
  const [open, setOpen] = useState(false);

  const handleDelete = async () => {
    setIsDeleting(true);

    try {
      const response = await fetch(`/api/exams/${examId}`, {
        method: 'DELETE',
      });

      if (response.ok) {
        onDeleted();
        setOpen(false);
      }
    } catch (error) {
      console.error('Error deleting exam:', error);
    } finally {
      setIsDeleting(false);
    }
  };

  return (
    <AlertDialog open={open} onOpenChange={setOpen}>
      <AlertDialogTrigger asChild>
        <Button variant="destructive" size="sm">
          <Trash2 className="mr-2 h-4 w-4" />
          Delete
        </Button>
      </AlertDialogTrigger>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Delete Exam</AlertDialogTitle>
          <AlertDialogDescription className="space-y-2">
            <span className="block">
              Are you sure you want to delete <strong>{examName}</strong>?
            </span>
            {questionCount > 0 && (
              <span className="block text-destructive">
                This will permanently delete {questionCount} questions and all associated progress data.
              </span>
            )}
            <span className="block">This action cannot be undone.</span>
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
          <AlertDialogAction
            onClick={handleDelete}
            disabled={isDeleting}
            className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
          >
            {isDeleting && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
            Delete
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}
```

### Step 9: Create the Exam Components Index

Create an index file for the exam components. Create `src/components/exam/index.ts`:

```typescript
// src/components/exam/index.ts

export { ExamCard } from './exam-card';
export { ExamForm } from './exam-form';
export { DeleteExamDialog } from './delete-exam-dialog';
```

### Step 10: Update the Exam List Page

Update the exam list page to fetch and display real data. Update `src/app/admin/exams/page.tsx`:

```typescript
// src/app/admin/exams/page.tsx

'use client';

import { useEffect, useState } from 'react';
import { MainLayout } from '@/components/layout';
import { ExamCard } from '@/components/exam';
import { Card, CardContent, CardDescription, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Plus, BookOpen, Loader2, RefreshCw } from 'lucide-react';
import Link from 'next/link';
import type { ExamListItem, ExamListResponse, ApiError } from '@/types';

export default function ExamsPage() {
  const [exams, setExams] = useState<ExamListItem[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchExams = async () => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/exams');

      if (!response.ok) {
        const errorData: ApiError = await response.json();
        setError(errorData.error.message);
        return;
      }

      const data: ExamListResponse = await response.json();
      setExams(data.exams);
    } catch {
      setError('Failed to load exams. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchExams();
  }, []);

  return (
    <MainLayout>
      <div className="space-y-6">
        <div className="flex items-center justify-between">
          <div>
            <h1 className="text-3xl font-bold tracking-tight">Exams</h1>
            <p className="text-muted-foreground">
              Manage your certification exams.
            </p>
          </div>
          <Button asChild>
            <Link href="/admin/exams/new">
              <Plus className="mr-2 h-4 w-4" />
              New Exam
            </Link>
          </Button>
        </div>

        {/* Loading State */}
        {isLoading && (
          <div className="flex items-center justify-center py-12">
            <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
          </div>
        )}

        {/* Error State */}
        {error && !isLoading && (
          <Card>
            <CardContent className="flex flex-col items-center justify-center py-12">
              <CardTitle className="mb-2 text-destructive">Error</CardTitle>
              <CardDescription className="text-center mb-4">{error}</CardDescription>
              <Button variant="outline" onClick={fetchExams}>
                <RefreshCw className="mr-2 h-4 w-4" />
                Retry
              </Button>
            </CardContent>
          </Card>
        )}

        {/* Empty State */}
        {!isLoading && !error && exams.length === 0 && (
          <Card>
            <CardContent className="flex flex-col items-center justify-center py-12">
              <BookOpen className="h-12 w-12 text-muted-foreground mb-4" />
              <CardTitle className="mb-2">No exams yet</CardTitle>
              <CardDescription className="text-center mb-4">
                Create your first exam to start importing questions.
              </CardDescription>
              <Button asChild>
                <Link href="/admin/exams/new">
                  <Plus className="mr-2 h-4 w-4" />
                  Create Exam
                </Link>
              </Button>
            </CardContent>
          </Card>
        )}

        {/* Exam List */}
        {!isLoading && !error && exams.length > 0 && (
          <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-1">
            {exams.map((exam) => (
              <ExamCard key={exam.id} exam={exam} />
            ))}
          </div>
        )}
      </div>
    </MainLayout>
  );
}
```

### Step 11: Update the New Exam Page

Update the new exam page to use the form component. Update `src/app/admin/exams/new/page.tsx`:

```typescript
// src/app/admin/exams/new/page.tsx

'use client';

import { useRouter } from 'next/navigation';
import { MainLayout } from '@/components/layout';
import { ExamForm } from '@/components/exam';
import { Button } from '@/components/ui/button';
import { ArrowLeft } from 'lucide-react';
import Link from 'next/link';

export default function NewExamPage() {
  const router = useRouter();

  return (
    <MainLayout>
      <div className="space-y-6">
        <div className="flex items-center gap-4">
          <Button variant="ghost" size="icon" asChild>
            <Link href="/admin/exams">
              <ArrowLeft className="h-4 w-4" />
            </Link>
          </Button>
          <div>
            <h1 className="text-3xl font-bold tracking-tight">New Exam</h1>
            <p className="text-muted-foreground">
              Create a new certification exam.
            </p>
          </div>
        </div>

        <ExamForm onCancel={() => router.push('/admin/exams')} />
      </div>
    </MainLayout>
  );
}
```

### Step 12: Create the Exam Detail Page

Create the exam detail page showing stats and management options. Create `src/app/admin/exams/[examId]/page.tsx`:

```typescript
// src/app/admin/exams/[examId]/page.tsx

'use client';

import { useEffect, useState } from 'react';
import { useRouter, useParams } from 'next/navigation';
import { MainLayout } from '@/components/layout';
import { DeleteExamDialog } from '@/components/exam';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import {
  ArrowLeft,
  BookOpen,
  CheckCircle,
  BarChart3,
  Clock,
  Upload,
  Play,
  Loader2,
} from 'lucide-react';
import Link from 'next/link';
import type { ExamDetailResponse, ApiError } from '@/types';

export default function ExamDetailPage() {
  const router = useRouter();
  const params = useParams();
  const examId = params.examId as string;

  const [exam, setExam] = useState<ExamDetailResponse | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchExam = async () => {
      try {
        const response = await fetch(`/api/exams/${examId}`);

        if (!response.ok) {
          const errorData: ApiError = await response.json();
          setError(errorData.error.message);
          return;
        }

        const data: ExamDetailResponse = await response.json();
        setExam(data);
      } catch {
        setError('Failed to load exam details.');
      } finally {
        setIsLoading(false);
      }
    };

    fetchExam();
  }, [examId]);

  const handleDeleted = () => {
    router.push('/admin/exams');
  };

  if (isLoading) {
    return (
      <MainLayout>
        <div className="flex items-center justify-center py-12">
          <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
        </div>
      </MainLayout>
    );
  }

  if (error || !exam) {
    return (
      <MainLayout>
        <div className="space-y-6">
          <div className="flex items-center gap-4">
            <Button variant="ghost" size="icon" asChild>
              <Link href="/admin/exams">
                <ArrowLeft className="h-4 w-4" />
              </Link>
            </Button>
            <h1 className="text-3xl font-bold tracking-tight">Error</h1>
          </div>
          <Card>
            <CardContent className="py-8 text-center">
              <p className="text-muted-foreground">{error || 'Exam not found'}</p>
              <Button asChild className="mt-4" variant="outline">
                <Link href="/admin/exams">Back to Exams</Link>
              </Button>
            </CardContent>
          </Card>
        </div>
      </MainLayout>
    );
  }

  const hasQuestions = exam.stats.totalQuestions > 0;

  return (
    <MainLayout>
      <div className="space-y-6">
        {/* Header */}
        <div className="flex items-start justify-between">
          <div className="flex items-center gap-4">
            <Button variant="ghost" size="icon" asChild>
              <Link href="/admin/exams">
                <ArrowLeft className="h-4 w-4" />
              </Link>
            </Button>
            <div>
              <h1 className="text-3xl font-bold tracking-tight">{exam.name}</h1>
              {exam.description && (
                <p className="text-muted-foreground mt-1">{exam.description}</p>
              )}
            </div>
          </div>
          <DeleteExamDialog
            examId={exam.id}
            examName={exam.name}
            questionCount={exam.stats.totalQuestions}
            onDeleted={handleDeleted}
          />
        </div>

        {/* Stats Cards */}
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
          <Card>
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <CardTitle className="text-sm font-medium">Total Questions</CardTitle>
              <BookOpen className="h-4 w-4 text-muted-foreground" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">{exam.stats.totalQuestions}</div>
            </CardContent>
          </Card>
          <Card>
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <CardTitle className="text-sm font-medium">Answered</CardTitle>
              <CheckCircle className="h-4 w-4 text-muted-foreground" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">{exam.stats.answered}</div>
              <p className="text-xs text-muted-foreground">
                {exam.stats.correct} correct
              </p>
            </CardContent>
          </Card>
          <Card>
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <CardTitle className="text-sm font-medium">Accuracy</CardTitle>
              <BarChart3 className="h-4 w-4 text-muted-foreground" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">
                {exam.stats.answered > 0 ? `${exam.stats.accuracy}%` : '-'}
              </div>
            </CardContent>
          </Card>
          <Card>
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <CardTitle className="text-sm font-medium">Due for Review</CardTitle>
              <Clock className="h-4 w-4 text-muted-foreground" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">{exam.stats.dueForReview}</div>
            </CardContent>
          </Card>
        </div>

        {/* Actions */}
        <Card>
          <CardHeader>
            <CardTitle>Actions</CardTitle>
            <CardDescription>
              {hasQuestions
                ? 'Start studying or import more questions.'
                : 'Import questions to get started.'}
            </CardDescription>
          </CardHeader>
          <CardContent className="flex gap-4">
            {hasQuestions && (
              <Button asChild>
                <Link href={`/study/${exam.id}`}>
                  <Play className="mr-2 h-4 w-4" />
                  Start Study
                </Link>
              </Button>
            )}
            <Button variant={hasQuestions ? 'outline' : 'default'} disabled>
              <Upload className="mr-2 h-4 w-4" />
              Import Questions
            </Button>
            <p className="text-sm text-muted-foreground self-center">
              Import will be available in Task 2.2-2.4
            </p>
          </CardContent>
        </Card>

        {/* Section Breakdown */}
        {exam.stats.bySection.length > 0 && (
          <Card>
            <CardHeader>
              <CardTitle>Performance by Section</CardTitle>
              <CardDescription>
                Your accuracy breakdown by exam section.
              </CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {exam.stats.bySection.map((section) => (
                  <div key={section.sectionId} className="space-y-2">
                    <div className="flex items-center justify-between text-sm">
                      <span className="font-medium">
                        {section.sectionId} - {section.section}
                      </span>
                      <div className="flex items-center gap-2">
                        <Badge variant={section.accuracy < 60 ? 'destructive' : 'secondary'}>
                          {section.accuracy}%
                        </Badge>
                        <span className="text-muted-foreground">
                          ({section.correct}/{section.total})
                        </span>
                      </div>
                    </div>
                    <div className="h-2 bg-muted rounded-full overflow-hidden">
                      <div
                        className={`h-full transition-all ${
                          section.accuracy < 60 ? 'bg-destructive' : 'bg-primary'
                        }`}
                        style={{ width: `${section.accuracy}%` }}
                      />
                    </div>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        )}

        {/* Empty Questions State */}
        {!hasQuestions && (
          <Card>
            <CardContent className="flex flex-col items-center justify-center py-12">
              <BookOpen className="h-12 w-12 text-muted-foreground mb-4" />
              <CardTitle className="mb-2">No questions yet</CardTitle>
              <CardDescription className="text-center mb-4">
                Import questions from a ZIP file to start studying.
              </CardDescription>
              <Button disabled>
                <Upload className="mr-2 h-4 w-4" />
                Import Questions
              </Button>
              <p className="text-sm text-muted-foreground mt-2">
                Available in Task 2.2-2.4
              </p>
            </CardContent>
          </Card>
        )}
      </div>
    </MainLayout>
  );
}
```

### Step 13: Verify the Implementation

Run the development server and test the functionality:

```bash
# Start PostgreSQL (if not running)
./scripts/start.sh

# Start the dev server
npm run dev
```

Test the following:

1. Navigate to `/admin/exams` - should show empty state
2. Click "New Exam" - should navigate to `/admin/exams/new`
3. Submit the form with valid data - should create exam and redirect
4. Try creating an exam with duplicate name - should show error
5. View the exam detail page - should show stats cards
6. Delete an exam - should confirm and redirect to list

## Documentation Updates

After completing the implementation, update the project documentation:

### Update `.claude/docs/07-implementation-tasks.md`

Mark completed items with `[x]`:

```markdown
### 2.1 Exam Management

**Read:** `06-api-specification.md` (Exams section)
- [x] Create exam list page (`/admin/exams`)
- [x] Create exam form component
- [x] Create new exam page (`/admin/exams/new`)
- [x] Implement `POST /api/exams` endpoint
- [x] Implement `GET /api/exams` endpoint
- [x] Implement `DELETE /api/exams/{id}` endpoint
- [x] Create exam detail page (`/admin/exams/[id]`)
```

### Update `.claude/docs/02-technical-architecture.md`

Add to the Project Structure section if not already present:

```markdown
src/
├── components/
│   ├── exam/               # Exam management components
│   │   ├── exam-card.tsx   # Exam list item card
│   │   ├── exam-form.tsx   # Create/edit exam form
│   │   ├── delete-exam-dialog.tsx  # Deletion confirmation
│   │   └── index.ts        # Component exports
```

### Update `.claude/docs/00-quick-reference.md`

Add any new commands or tips:

```markdown
## Form Libraries

- React Hook Form + Zod for form validation
- `npm install react-hook-form zod @hookform/resolvers`
```

## Acceptance Criteria

Before marking this task complete, verify:

1. [ ] `GET /api/exams` returns list of exams with stats
2. [ ] `POST /api/exams` creates new exam with validation
3. [ ] `GET /api/exams/[examId]` returns exam with detailed stats
4. [ ] `DELETE /api/exams/[examId]` deletes exam and cascades
5. [ ] Exam list page shows loading, empty, error, and list states
6. [ ] New exam form validates input and shows errors
7. [ ] Duplicate exam names are rejected
8. [ ] Exam detail page shows stats cards and section breakdown
9. [ ] Delete confirmation dialog works and redirects
10. [ ] No TypeScript errors (`npm run build`)
11. [ ] Documentation in `.claude/docs/` is updated to reflect changes
12. [ ] Task items in `07-implementation-tasks.md` are marked as complete `[x]`

## Git Completion

After all acceptance criteria pass:

```bash
# Stage all changes (including doc updates)
git add .

# Commit with conventional commit message
git commit -m "$(cat <<'EOF'
feat(admin): implement exam management CRUD

- Add GET/POST /api/exams endpoints
- Add GET/DELETE /api/exams/[examId] endpoints
- Create ExamCard, ExamForm, DeleteExamDialog components
- Add exam list page with loading/error/empty states
- Add exam detail page with stats and section breakdown
- Install react-hook-form, zod for form validation
- docs: updated implementation-tasks.md

Task: 2.1
EOF
)"

# Push branch to remote
git push -u origin feature/2.1-exam-management

# Create PR to dev branch
gh pr create --base dev --title "feat(admin): implement exam management CRUD" --body "$(cat <<'EOF'
## Summary
Implements complete exam management functionality for Phase 2.

## Task Reference
Task 2.1 from implementation roadmap

## Changes
- API endpoints: GET/POST /api/exams, GET/DELETE /api/exams/[examId]
- Components: ExamCard, ExamForm, DeleteExamDialog
- Pages: Exam list with states, exam detail with stats
- Form validation with react-hook-form and zod
- TypeScript types for all API responses

## Documentation Updated
- [ ] `07-implementation-tasks.md` - marked tasks complete
- [ ] `02-technical-architecture.md` - added component structure
- [ ] `00-quick-reference.md` - added form library notes

## Testing
- [ ] GET /api/exams returns list with stats
- [ ] POST /api/exams creates exam with validation
- [ ] GET /api/exams/[id] returns exam details
- [ ] DELETE /api/exams/[id] cascades correctly
- [ ] UI states (loading, empty, error) work
- [ ] Form validation shows errors
- [ ] Delete confirmation works
- [ ] No TypeScript errors
EOF
)"
```

## Notes

- **OUT OF SCOPE**: Question import (Task 2.2-2.4), question list view, study functionality
- **ASSUMPTION**: PostgreSQL is running and accessible via the DATABASE_URL environment variable
- **DEPENDENCY**: Prisma schema and client from Phase 1 (Task 1.3)
- **WARNING**: The exam detail page's "Import Questions" button is intentionally disabled - this functionality will be implemented in Tasks 2.2-2.4
- **WARNING**: The "Start Study" link points to `/study/[examId]` which doesn't exist yet - this is expected and will be implemented in Phase 3
