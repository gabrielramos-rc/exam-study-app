# Task 1.3: Database Setup

## Context

This task is part of Phase 1 (Project Foundation) for the Exam Study App. After the project was initialized (Task 1.1) and styling was configured (Task 1.2), we now need to set up the database layer using Prisma ORM with PostgreSQL. The app uses PostgreSQL with JSONB fields for flexible question data storage. This task creates the Prisma schema, client singleton, and prepares for migrations.

## Objective

Install Prisma ORM, create the complete database schema with all models, and set up the Prisma client singleton for use throughout the application.

## Git Workflow

Before starting, set up your branch:

```bash
# Ensure you're on dev and up to date
git checkout dev
git pull origin dev

# Create task-specific branch
git checkout -b feature/1.3-database-setup
```

## Instructions

### Step 1: Install Prisma

Install Prisma as a dev dependency and the Prisma client:

```bash
npm install prisma --save-dev
npm install @prisma/client
```

Initialize Prisma with PostgreSQL:

```bash
npx prisma init --datasource-provider postgresql
```

This creates:
- `prisma/schema.prisma` - The Prisma schema file
- `.env` - Environment variables file (if not exists, or adds DATABASE_URL)

### Step 2: Create the Prisma Schema

Replace the contents of `prisma/schema.prisma` with the following complete schema:

```prisma
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// EXAM
// ============================================
model Exam {
  id          String   @id @default(cuid())
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  questions   Question[]
  progress    StudyProgress[]
}

// ============================================
// QUESTION
// ============================================
model Question {
  id        String   @id @default(cuid())
  examId    String
  exam      Exam     @relation(fields: [examId], references: [id], onDelete: Cascade)
  number    Int
  data      Json     // Full question data as JSONB
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  answers   Answer[]
  srsCard   SrsCard?
  bookmarks Bookmark[]

  // Constraints
  @@unique([examId, number])
  @@index([examId])
}

// ============================================
// STUDY PROGRESS (Snapshot for export/import)
// ============================================
model StudyProgress {
  id        String   @id @default(cuid())
  examId    String
  exam      Exam     @relation(fields: [examId], references: [id], onDelete: Cascade)
  name      String   @default("Default")
  data      Json     // Full progress snapshot
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([examId])
}

// ============================================
// ANSWER (History of answers)
// ============================================
model Answer {
  id          String   @id @default(cuid())
  questionId  String
  question    Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  selected    String[] // Array of selected options ["A", "C"]
  correct     Boolean
  timeSpentMs Int?
  answeredAt  DateTime @default(now())

  @@index([questionId])
  @@index([answeredAt])
}

// ============================================
// SRS CARD (Spaced repetition state)
// ============================================
model SrsCard {
  id           String    @id @default(cuid())
  questionId   String    @unique
  question     Question  @relation(fields: [questionId], references: [id], onDelete: Cascade)
  easeFactor   Float     @default(2.5)
  intervalDays Int       @default(0)
  repetitions  Int       @default(0)
  nextReview   DateTime  @default(now())
  lastReview   DateTime?
  lastGrade    Int?      // 0-5 scale

  @@index([nextReview])
}

// ============================================
// BOOKMARK
// ============================================
model Bookmark {
  id         String   @id @default(cuid())
  questionId String   @unique
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())
}

// ============================================
// SETTINGS (Key-value store)
// ============================================
model Settings {
  key       String   @id
  value     String
  updatedAt DateTime @updatedAt
}
```

### Step 3: Create Prisma Client Singleton

Create `src/lib/prisma.ts` with the following content. This singleton pattern prevents multiple Prisma Client instances during development hot reloads:

```typescript
// src/lib/prisma.ts

import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
  });

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}

export default prisma;
```

### Step 4: Update Environment Variables

Ensure your `.env` file contains the correct DATABASE_URL. Update it to match:

```bash
# Database
DATABASE_URL=postgresql://study:study@localhost:5432/study

# App
NODE_ENV=development
PORT=3000
UPLOAD_MAX_SIZE=52428800
```

Also update `.env.example` to have the same DATABASE_URL template:

```bash
# Database
DATABASE_URL=postgresql://study:study@localhost:5432/study

# App
NODE_ENV=development
PORT=3000
UPLOAD_MAX_SIZE=52428800
```

### Step 5: Generate Prisma Client

Generate the Prisma Client (this does NOT require a database connection):

```bash
npx prisma generate
```

This creates the TypeScript types and client in `node_modules/.prisma/client`.

### Step 6: Verify TypeScript Integration

Create a temporary test file to verify Prisma types work. Create `src/lib/prisma-test.ts`:

```typescript
// src/lib/prisma-test.ts
// Temporary file to verify Prisma types - DELETE AFTER VERIFICATION

import { prisma } from './prisma';
import type { Exam, Question, Answer, SrsCard, Bookmark, StudyProgress, Settings } from '@prisma/client';

// Type verification - these should not show TypeScript errors
type ExamWithQuestions = Exam & { questions: Question[] };
type QuestionWithRelations = Question & {
  answers: Answer[];
  srsCard: SrsCard | null;
  bookmarks: Bookmark[]
};

// Example query shape verification (won't run without DB)
async function _typeTest() {
  // Exam queries
  const exams = await prisma.exam.findMany({
    include: { questions: true }
  });

  // Question queries
  const questions = await prisma.question.findMany({
    where: { examId: 'test' },
    orderBy: { number: 'asc' }
  });

  // SRS queries
  const dueCards = await prisma.srsCard.findMany({
    where: {
      nextReview: { lte: new Date() }
    },
    include: { question: true }
  });

  return { exams, questions, dueCards };
}

export type { ExamWithQuestions, QuestionWithRelations };
```

Run TypeScript check to verify no errors:

```bash
npx tsc --noEmit
```

If successful, delete the test file:

```bash
rm src/lib/prisma-test.ts
```

### Step 7: Add Prisma to .gitignore

Ensure the following entries are in `.gitignore` (they may already be there from Task 1.1):

```gitignore
# Prisma
/prisma/migrations/**/migration_lock.toml
```

## Documentation Updates

After completing the implementation, update the project documentation:

### Update `.claude/docs/07-implementation-tasks.md`

Mark completed items with `[x]`:

```markdown
### 1.3 Database Setup
**Read:** `03-data-schema.md` (full document)
- [x] Install Prisma
- [x] Create `schema.prisma` with all models (copy from `03-data-schema.md`)
- [x] Set up Prisma client singleton (`lib/prisma.ts`)
- [ ] Create initial migration *(moved to Task 1.4)*
```

### Update `.claude/docs/00-quick-reference.md`

Add Prisma commands to the quick reference:

```markdown
## Prisma Commands

```bash
npx prisma generate          # Regenerate client after schema changes
npx prisma migrate dev       # Create and apply migration (dev)
npx prisma migrate deploy    # Apply migrations (prod)
npx prisma studio            # Visual database editor at localhost:5555
npx prisma db push           # Push schema without migrations (prototyping)
npx prisma format            # Format schema file
```
```

### Verify `.claude/docs/03-data-schema.md`

Confirm that the schema in `prisma/schema.prisma` matches exactly what's documented in `03-data-schema.md`. They should be identical.

## Acceptance Criteria

Before marking this task complete, verify:

1. `prisma/schema.prisma` exists with all 7 models:
   - [ ] Exam
   - [ ] Question (with JSONB `data` field)
   - [ ] StudyProgress
   - [ ] Answer
   - [ ] SrsCard
   - [ ] Bookmark
   - [ ] Settings
2. `src/lib/prisma.ts` exists and exports the Prisma client singleton
3. `npx prisma generate` completes without errors
4. `npx tsc --noEmit` passes with no TypeScript errors
5. `.env` and `.env.example` have the correct `DATABASE_URL`
6. Documentation in `.claude/docs/` is updated:
   - [ ] `07-implementation-tasks.md` - tasks marked complete
   - [ ] `00-quick-reference.md` - Prisma commands added

**Note**: Migrations will be created and applied in Task 1.4 after PostgreSQL is deployed.

## Git Completion

After all acceptance criteria pass:

```bash
# Stage all changes (including doc updates)
git add .

# Commit with conventional commit message
git commit -m "$(cat <<'EOF'
feat(db): set up Prisma ORM with complete database schema

- Install prisma and @prisma/client packages
- Create schema.prisma with 7 models (Exam, Question, StudyProgress, Answer, SrsCard, Bookmark, Settings)
- Set up Prisma client singleton with development hot-reload handling
- Configure DATABASE_URL for PostgreSQL connection
- Generate Prisma client with TypeScript types
- Migrations deferred to Task 1.4 (requires PostgreSQL)
- docs: updated 07-implementation-tasks.md and 00-quick-reference.md

Task: 1.3

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"

# Push branch to remote
git push -u origin feature/1.3-database-setup

# Create PR to dev branch
gh pr create --base dev --title "feat(db): Set up Prisma ORM with database schema" --body "$(cat <<'EOF'
## Summary
Set up Prisma ORM with the complete database schema for the Exam Study App.

## Task Reference
Task 1.3 from implementation roadmap

## Changes
- Installed `prisma` and `@prisma/client` packages
- Created `prisma/schema.prisma` with 7 models:
  - Exam - Container for questions
  - Question - Questions with JSONB data field
  - StudyProgress - Progress snapshots for export/import
  - Answer - Answer history
  - SrsCard - Spaced repetition state (SM-2)
  - Bookmark - Flagged questions
  - Settings - Key-value configuration
- Created Prisma client singleton at `src/lib/prisma.ts`
- Updated environment variables

## Documentation Updated
- [x] `07-implementation-tasks.md` - marked tasks complete
- [x] `00-quick-reference.md` - added Prisma commands

## Testing
- [x] `npx prisma generate` completes successfully
- [x] `npx tsc --noEmit` passes with no errors
- [x] All 7 models defined in schema
- [x] Prisma client singleton exports correctly
EOF
)"
```

## Notes

- **OUT OF SCOPE**: Do not set up PostgreSQL in Docker/Kubernetes - that's Task 1.4
- **OUT OF SCOPE**: Do not run database migrations - that's Task 1.4 after PostgreSQL is deployed
- **OUT OF SCOPE**: Do not create any API endpoints using Prisma - that's Phase 2
- **OUT OF SCOPE**: Do not create the layout or navigation components - that's Task 1.5
- The `log` option in PrismaClient is set to show queries in development for debugging purposes
- The Prisma client singleton pattern prevents the "Too many clients already" error during Next.js hot reloads
- JSONB fields (`data` in Question and StudyProgress) allow flexible schema evolution without migrations
- All relations use `onDelete: Cascade` to maintain referential integrity when deleting exams or questions
